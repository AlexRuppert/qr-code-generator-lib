import { chunkString, range } from './utilities'

export enum EcLevels {
  L = 0,
  M = 1,
  Q = 2,
  H = 3,
}

//interleaved data --> ecPerBlock, wordsPerBlock
let qrDefinitionTable = chunkString(
  '0011030906060a020325091a14141a0908441834100a1406126710231816090218921633100814041056091916111a0812651022100718061682142914101807219a1427120916051056183316111a081268213a1a1416051678142718121a0718911428161214042199163012091605147316312116160516831a35161121081a911a361a141a0721a318331a141a071a971834181318061a91183121161a081a9a18321a1421091a951a362116160621a41a372116210821a01a352116210918901a37211621081a981a361a14210921a51a352115210821a01a3521162108219a1a352115210821991a372116210821991a362116210821991a362116210821991a362116210821991a362116210921a41a372116210821a41a372116210821a51a362116210821a51a362116210821a01a372116210821a11a3721162108',
  2,
).map((s) => parseInt(s, 11) + 7)
/*[
  7,
  19,
  10,
  16,
  13,
  13,
  17,
  9,
  10,
  34,
  16,
  28,
  22,
  22,
  28,
  16,
  15,
  55,
  26,
  44,
  18,
  17,
  22,
  13,
  20,
  80,
  18,
  32,
  26,
  24,
  16,
  9,
  26,
  108,
  24,
  43,
  18,
  15,
  22,
  11,
  18,
  68,
  16,
  27,
  24,
  19,
  28,
  15,
  20,
  78,
  18,
  31,
  18,
  14,
  26,
  13,
  24,
  97,
  22,
  38,
  22,
  18,
  26,
  14,
  30,
  116,
  22,
  36,
  20,
  16,
  24,
  12,
  18,
  68,
  26,
  43,
  24,
  19,
  28,
  15,
  20,
  81,
  30,
  50,
  28,
  22,
  24,
  12,
  24,
  92,
  22,
  36,
  26,
  20,
  28,
  14,
  26,
  107,
  22,
  37,
  24,
  20,
  22,
  11,
  30,
  115,
  24,
  40,
  20,
  16,
  24,
  12,
  22,
  87,
  24,
  41,
  30,
  24,
  24,
  12,
  24,
  98,
  28,
  45,
  24,
  19,
  30,
  15,
  28,
  107,
  28,
  46,
  28,
  22,
  28,
  14,
  30,
  120,
  26,
  43,
  28,
  22,
  28,
  14,
  28,
  113,
  26,
  44,
  26,
  21,
  26,
  13,
  28,
  107,
  26,
  41,
  30,
  24,
  28,
  15,
  28,
  116,
  26,
  42,
  28,
  22,
  30,
  16,
  28,
  111,
  28,
  46,
  30,
  24,
  24,
  13,
  30,
  121,
  28,
  47,
  30,
  24,
  30,
  15,
  30,
  117,
  28,
  45,
  30,
  24,
  30,
  16,
  26,
  106,
  28,
  47,
  30,
  24,
  30,
  15,
  28,
  114,
  28,
  46,
  28,
  22,
  30,
  16,
  30,
  122,
  28,
  45,
  30,
  23,
  30,
  15,
  30,
  117,
  28,
  45,
  30,
  24,
  30,
  15,
  30,
  116,
  28,
  45,
  30,
  23,
  30,
  15,
  30,
  115,
  28,
  47,
  30,
  24,
  30,
  15,
  30,
  115,
  28,
  46,
  30,
  24,
  30,
  15,
  30,
  115,
  28,
  46,
  30,
  24,
  30,
  15,
  30,
  115,
  28,
  46,
  30,
  24,
  30,
  15,
  30,
  115,
  28,
  46,
  30,
  24,
  30,
  16,
  30,
  121,
  28,
  47,
  30,
  24,
  30,
  15,
  30,
  121,
  28,
  47,
  30,
  24,
  30,
  15,
  30,
  122,
  28,
  46,
  30,
  24,
  30,
  15,
  30,
  122,
  28,
  46,
  30,
  24,
  30,
  15,
  30,
  117,
  28,
  47,
  30,
  24,
  30,
  15,
  30,
  118,
  28,
  47,
  30,
  24,
  30,
  15,
]*/

export let getDimensions = (version: number) =>
  //return (version - 1) * 4 + 21
  4 * version + 17

let getSupportedBits = (version: number) => {
  let dimensions = getDimensions(version)

  let alignmentElementsDimensions = 2 + (0 | (version / 7))
  let alignmentModules =
    (5 * alignmentElementsDimensions - 1) *
      (5 * alignmentElementsDimensions - 1) -
    56
  let versionInfoModules = 36

  return (
    dimensions * dimensions -
    2 * dimensions -
    191 -
    alignmentModules * +(version > 1) -
    versionInfoModules * +(version > 6)
  )
}

export let getRemainderBits = (version: number) => getSupportedBits(version) % 8

export let getAlignmentPattern = (version: number) => {
  let last = 4 + 4 * version
  let elements = 0 | (version / 7)
  let startStep = 0 | (last / (elements + 1))
  let firstStep = startStep
  let nextStep = firstStep

  if (elements > 1) {
    nextStep = 2 * Math.ceil(((last - startStep) / elements + 0.0001) / 2)
    firstStep = last - nextStep * elements
  }

  return version < 2
    ? []
    : [6, ...range(0, elements + 1).map((i) => 6 + firstStep + i * nextStep)]
}

export let getGroups = (version: number, ecLevel: EcLevels) => {
  let index = version * 8 - 8 + ecLevel * 2,
    ecPerBlock = qrDefinitionTable[index],
    wordsPerBlock = qrDefinitionTable[++index],
    bytes = 0 | (getSupportedBits(version) / 8),
    y = 0,
    x = 0,
    sumBlock = ecPerBlock + wordsPerBlock

  for (; x < 57; x++)
    if ((y = (bytes - sumBlock * x) / (sumBlock + 1)) % 1 === 0) break

  let result = [{ blocks: x, wordsPerBlock, ecPerBlock }]
  y > 0 && wordsPerBlock++
  result.push({ blocks: y, wordsPerBlock, ecPerBlock })

  return result
}

export let getChracterCountBits = (version: number) => (version <= 9 ? 8 : 16)

export let getRequiredNumberOfBits = (
  groups: { wordsPerBlock: number; blocks: number }[],
) => groups.reduce((acc, val) => acc + val.wordsPerBlock * val.blocks, 0) * 8
